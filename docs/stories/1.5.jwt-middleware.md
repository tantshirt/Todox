# Story 1.5: JWT Authentication Middleware & Protected Routes

## Status
Ready

## Story

**As the** system,  
**I want** to verify JWT tokens on protected routes,  
**so that** only authenticated users can access their data.

## Acceptance Criteria

1. FastAPI dependency (`core/deps.py`) implements JWT verification that extracts and validates tokens from Authorization header
2. Dependency decodes JWT, verifies signature, checks expiry, and returns user_id
3. Invalid, expired, or missing tokens return 401 Unauthorized with clear error message
4. Test endpoint `GET /auth/me` requires authentication and returns current user's email and id
5. CORS middleware configured to allow requests from frontend origin (via `CORS_ORIGINS` environment variable)
6. Unit tests cover: valid token acceptance, expired token rejection, invalid signature rejection, missing token rejection
7. Integration test verifies: register → login → access protected route flow

## Tasks / Subtasks

- [ ] Task 1: Create JWT verification middleware (AC: 1, 2, 3)
  - [ ] Create `backend/src/middleware/auth_middleware.py`
  - [ ] Import FastAPI security: `from fastapi.security import HTTPBearer, HTTPAuthCredentials`
  - [ ] Create `security = HTTPBearer()` instance
  - [ ] Implement `async def get_current_user(credentials: HTTPAuthCredentials = Depends(security), db = Depends(get_database)) -> User`
  - [ ] Extract token from credentials: `token = credentials.credentials`
  - [ ] Decode JWT using `jose.jwt.decode(token, settings.JWT_SECRET, algorithms=[settings.JWT_ALGORITHM])`
  - [ ] Extract user_id from payload `sub` field
  - [ ] Check token expiry: verify `exp` field > current timestamp
  - [ ] Fetch user from database using user_repository.find_by_id()
  - [ ] Raise HTTPException(401, "Could not validate credentials") for: invalid token, expired token, user not found
  - [ ] Return User object on success

- [ ] Task 2: Configure CORS middleware (AC: 5)
  - [ ] Update `backend/src/main.py`
  - [ ] Import `from fastapi.middleware.cors import CORSMiddleware`
  - [ ] Add CORS middleware to app with: `allowed_origins` from settings.CORS_ORIGINS (split by comma), `allow_credentials=True`, `allow_methods=["*"]`, `allow_headers=["*"]`
  - [ ] Ensure CORS_ORIGINS environment variable is set to frontend URL (http://localhost:3000 for dev)

- [ ] Task 3: Create test endpoint for authentication verification (AC: 4)
  - [ ] Update `backend/src/api/v1/auth.py`
  - [ ] Implement `GET /auth/me` endpoint
  - [ ] Endpoint uses `current_user: User = Depends(get_current_user)` dependency
  - [ ] Return UserResponse with current user's data
  - [ ] Test manually with Authorization header: `Bearer {token}`

- [ ] Task 4: Write unit tests for JWT verification (AC: 6)
  - [ ] Update `backend/tests/test_auth.py`
  - [ ] Test valid token: create token with create_access_token(), call /auth/me, verify 200 response
  - [ ] Test expired token: create token with past expiry, call /auth/me, verify 401
  - [ ] Test invalid signature: create token with wrong secret, call /auth/me, verify 401
  - [ ] Test missing token: call /auth/me without Authorization header, verify 401
  - [ ] Test malformed token: send invalid JWT string, verify 401

- [ ] Task 5: Write integration test for complete auth flow (AC: 7)
  - [ ] Update `backend/tests/test_auth.py`
  - [ ] Test full flow:
    - [ ] POST /auth/register with email/password
    - [ ] POST /auth/login with same credentials
    - [ ] Extract access_token from response
    - [ ] GET /auth/me with Authorization: Bearer {token}
    - [ ] Verify user email matches registered email
  - [ ] Test flow ensures tokens work end-to-end

## Dev Notes

### JWT Verification Middleware

**[Source: docs/architecture/backend-architecture.md#Middleware/Guards]**

FastAPI uses dependency injection for middleware. The `get_current_user` dependency will be used on all protected routes.

**Implementation Pattern:**

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthCredentials
from jose import JWTError, jwt
from datetime import datetime
from bson import ObjectId

from src.core.config import settings
from src.core.database import get_database
from src.repositories.user_repository import UserRepository
from src.models.user import User

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthCredentials = Depends(security),
    db = Depends(get_database)
) -> User:
    """
    FastAPI dependency that verifies JWT token and returns current user.
    Raises 401 Unauthorized if token is invalid, expired, or user not found.
    """
    token = credentials.credentials
    
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(
            token,
            settings.JWT_SECRET,
            algorithms=[settings.JWT_ALGORITHM]
        )
        
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
        
        exp = payload.get("exp")
        if exp is None or datetime.utcnow().timestamp() > exp:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token has expired"
            )
        
    except JWTError:
        raise credentials_exception
    
    # Fetch user from database
    user_repo = UserRepository(db)
    user = await user_repo.find_by_id(ObjectId(user_id))
    
    if user is None:
        raise credentials_exception
    
    return user
```

### Using the Middleware in Routes

**[Source: docs/architecture/backend-architecture.md#Controller Template]**

Protected routes use the dependency:

```python
from src.middleware.auth_middleware import get_current_user

@router.get("/auth/me", response_model=UserResponse)
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """Get current authenticated user info."""
    return UserResponse(
        id=current_user.id,
        email=current_user.email,
        created_at=current_user.created_at,
        updated_at=current_user.updated_at
    )
```

### CORS Configuration

**[Source: docs/architecture/security-and-performance.md#Security Requirements]**

CORS must be configured to only allow requests from the frontend origin:

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS.split(","),  # ["http://localhost:3000"]
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

**Environment Variable:**
- Development: `CORS_ORIGINS=http://localhost:3000`
- Production: `CORS_ORIGINS=https://todox.vercel.app`

**Security Note:** NEVER use `allow_origins=["*"]` - this creates security vulnerabilities.

### API Specification

**[Source: docs/architecture/api-specification.md#/auth/me]**

**Endpoint:** `GET /auth/me`

**Request Headers:**
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Success Response (200 OK):**
```json
{
  "id": "507f1f77bcf86cd799439011",
  "email": "user@example.com",
  "created_at": "2025-01-12T10:00:00Z",
  "updated_at": "2025-01-12T10:00:00Z"
}
```

**Error Responses:**
- 401 Unauthorized: Missing, invalid, or expired token

### Critical Security Rules

**[Source: docs/architecture/coding-standards.md#Authentication]**

- **ALWAYS** use `get_current_user` dependency for protected routes
- **NEVER** manually parse JWT in route handlers
- **ALWAYS** check token expiry
- **NEVER** trust the user_id from request body - always get from verified token

### File Locations

**[Source: docs/architecture/backend-architecture.md]**

Create/update these files:
- `backend/src/middleware/auth_middleware.py` - JWT verification dependency
- `backend/src/api/v1/auth.py` - Add GET /auth/me endpoint
- `backend/src/main.py` - Add CORS middleware configuration
- `backend/tests/test_auth.py` - JWT verification tests

### Testing

**[Source: docs/architecture/testing-strategy.md]**

**Critical Test Scenarios:**

1. **Valid Token Test:** Generate valid token → Call protected endpoint → Should return 200
2. **Expired Token Test:** Generate token with past expiry → Call protected endpoint → Should return 401
3. **Invalid Signature Test:** Generate token with wrong secret → Call protected endpoint → Should return 401
4. **Missing Token Test:** Call protected endpoint without Authorization header → Should return 401
5. **Integration Flow Test:** Complete flow from registration to protected access

**Test Helper:**
```python
@pytest.fixture
def auth_headers(test_user):
    """Generate valid auth headers for testing."""
    from src.core.security import create_access_token
    token = create_access_token(str(test_user.id))
    return {"Authorization": f"Bearer {token}"}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-12 | 1.0 | Story created from Epic 1 | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent after implementation_
