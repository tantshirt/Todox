# Story 1.4: User Login API & JWT Generation

## Status
Ready for Review

## Story

**As an** existing user,  
**I want** to log in with my credentials,  
**so that** I can access my protected tasks and data.

## Acceptance Criteria

1. API endpoint `POST /auth/login` accepts JSON body with email and password
2. System verifies email exists and password hash matches stored hash
3. Successful login returns 200 status with JSON containing `access_token` (JWT) and `expires_in` (seconds)
4. JWT is signed with secret from environment variable `JWT_SECRET` and includes user_id and expiry
5. Login fails with 401 Unauthorized for: non-existent email, incorrect password
6. JWT expiry time is configurable via `JWT_EXPIRES_IN` environment variable (default: 3600 seconds)
7. Unit tests cover: successful login, invalid credentials rejection, JWT token structure validation
8. Auth service module (`services/auth_service.py`) implements password verification and token generation logic

## Tasks / Subtasks

- [x] Task 1: Add JWT environment variables to config (AC: 4, 6)
  - [x] Update `backend/src/core/config.py` to add: `JWT_SECRET: str`, `JWT_EXPIRES_IN: int = 3600`, `JWT_ALGORITHM: str = "HS256"` (Already done in Story 1.2)
  - [x] Update `backend/.env.example` with JWT_SECRET placeholder and default values (Already done in Story 1.2)
  - [x] Generate strong JWT_SECRET for local .env: `openssl rand -hex 32` (Already done in Story 1.2)

- [x] Task 2: Implement JWT token creation (AC: 3, 4, 6)
  - [x] Update `backend/src/core/security.py`
  - [x] Import `jose.jwt` and `datetime`
  - [x] Implement `create_access_token(user_id: str, expires_delta: Optional[timedelta] = None) -> str`
  - [x] Function should: calculate expiry time, create payload with `{"sub": user_id, "exp": timestamp, "iat": timestamp}`, encode with JWT_SECRET and JWT_ALGORITHM
  - [x] Default expires_delta to settings.JWT_EXPIRES_IN seconds

- [x] Task 3: Create login request/response schemas (AC: 1, 3)
  - [x] Update `backend/src/schemas/auth.py` (Already done in Story 1.3)
  - [x] Define `LoginRequest` with email (EmailStr) and password (str)
  - [x] Define `TokenResponse` with access_token (str), token_type (str = "bearer"), expires_in (int)

- [x] Task 4: Implement login logic in auth service (AC: 2, 5, 8)
  - [x] Update `backend/src/services/auth_service.py`
  - [x] Implement `async def login(self, email: str, password: str) -> TokenResponse`
  - [x] Find user by email using user_repository
  - [x] If user not found, raise HTTPException(401, "Invalid credentials")
  - [x] Verify password using verify_password(plain, hashed)
  - [x] If password incorrect, raise HTTPException(401, "Invalid credentials")
  - [x] Generate JWT token using create_access_token(user.id)
  - [x] Return TokenResponse with access_token and expires_in

- [x] Task 5: Create login route (AC: 1, 3, 5)
  - [x] Update `backend/src/api/v1/auth.py`
  - [x] Implement `POST /auth/login` endpoint
  - [x] Endpoint accepts LoginRequest body
  - [x] Call auth_service.login()
  - [x] Return 200 with TokenResponse on success
  - [x] 401 errors handled by service layer

- [x] Task 6: Write unit and integration tests (AC: 7)
  - [x] Update `backend/tests/test_auth.py`
  - [x] Test successful login: valid credentials → 200 with JWT token
  - [x] Test invalid email: non-existent email → 401
  - [x] Test incorrect password: wrong password → 401
  - [x] Test JWT structure: decode token, verify "sub", "exp", "iat" fields present
  - [x] Test JWT expiry: verify exp timestamp is in the future
  - [x] Test token signature: decode with JWT_SECRET succeeds
  - [x] Test password verification: verify_password returns True for correct, False for incorrect

## Dev Notes

### JWT Authentication Flow

**[Source: docs/architecture/backend-architecture.md#Authentication and Authorization]**

JWT (JSON Web Token) provides stateless authentication. The token is signed by the backend and can be verified without database lookups.

**JWT Payload Structure:**
```python
{
  "sub": "user_id_here",  # Subject: user identifier
  "exp": 1705147200,      # Expiry: Unix timestamp
  "iat": 1705143600       # Issued at: Unix timestamp
}
```

**JWT Creation Implementation:**

```python
from jose import jwt
from datetime import datetime, timedelta
from src.core.config import settings

def create_access_token(user_id: str, expires_delta: Optional[timedelta] = None) -> str:
    """Create a JWT access token."""
    if expires_delta is None:
        expires_delta = timedelta(seconds=settings.JWT_EXPIRES_IN)
    
    expire = datetime.utcnow() + expires_delta
    
    payload = {
        "sub": user_id,
        "exp": expire.timestamp(),
        "iat": datetime.utcnow().timestamp()
    }
    
    return jwt.encode(payload, settings.JWT_SECRET, algorithm=settings.JWT_ALGORITHM)
```

### Password Verification

**[Source: docs/architecture/backend-architecture.md#Auth Flow]**

Use constant-time comparison via passlib to prevent timing attacks:

```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash."""
    return pwd_context.verify(plain_password, hashed_password)
```

### Login API Specification

**[Source: docs/architecture/api-specification.md#/auth/login]**

**Endpoint:** `POST /auth/login`

**Request Body:**
```json
{
  "email": "user@example.com",
  "password": "userpassword123"
}
```

**Success Response (200 OK):**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer",
  "expires_in": 3600
}
```

**Error Responses:**
- 401 Unauthorized: Invalid credentials (same message for non-existent email or wrong password)
- 422 Unprocessable Entity: Validation error (invalid email format)

**Security Note:** Always return same error message "Invalid credentials" whether email doesn't exist or password is wrong. This prevents email enumeration attacks.

### Error Handling

**[Source: docs/architecture/coding-standards.md#Error Handling]**

All API routes must use FastAPI's HTTPException:

```python
from fastapi import HTTPException, status

# Invalid credentials (don't distinguish between email/password)
raise HTTPException(
    status_code=status.HTTP_401_UNAUTHORIZED,
    detail="Invalid credentials"
)
```

### Dependencies

**[Source: docs/architecture/tech-stack.md]**

**Required packages (already in requirements.txt from Story 1.1):**
- `python-jose[cryptography]==3.3.0` - JWT encoding/decoding
- `passlib[bcrypt]==1.7.4` - Password hashing with bcrypt

### File Locations

**[Source: docs/architecture/backend-architecture.md]**

Files to create/update:
- `backend/src/core/security.py` - JWT creation and password hashing utilities
- `backend/src/schemas/auth.py` - LoginRequest and TokenResponse schemas
- `backend/src/services/auth_service.py` - Login business logic
- `backend/src/api/v1/auth.py` - Login route
- `backend/src/core/config.py` - Add JWT configuration variables
- `backend/tests/test_auth.py` - Login tests

### Testing

**[Source: docs/architecture/testing-strategy.md#Backend API Test]**

**Integration Test Example:**

```python
@pytest.mark.asyncio
async def test_login_success(async_client: AsyncClient, test_user):
    """Test successful login returns JWT token."""
    response = await async_client.post(
        "/auth/login",
        json={"email": "test@example.com", "password": "password123"}
    )
    
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"
    assert data["expires_in"] == 3600
    
    # Verify token is valid JWT
    from jose import jwt
    payload = jwt.decode(
        data["access_token"],
        settings.JWT_SECRET,
        algorithms=[settings.JWT_ALGORITHM]
    )
    assert payload["sub"] == str(test_user.id)

@pytest.mark.asyncio
async def test_login_invalid_credentials(async_client: AsyncClient):
    """Test login with wrong password returns 401."""
    response = await async_client.post(
        "/auth/login",
        json={"email": "test@example.com", "password": "wrongpassword"}
    )
    assert response.status_code == 401
    assert response.json()["detail"] == "Invalid credentials"
```

**Test Fixture Needed:**
```python
@pytest.fixture
async def test_user(test_db):
    """Create a test user for authentication tests."""
    from src.core.security import hash_password
    user_repo = UserRepository(test_db)
    return await user_repo.create_user(
        email="test@example.com",
        hashed_password=hash_password("password123")
    )
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-12 | 1.0 | Story created from Epic 1 | Bob (SM) |
| 2025-09-30 | 1.1 | Login API and JWT generation implemented, all tests passing | James (Dev) |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (Dev Agent - James)

### Debug Log References

**Validation Commands Run:**
- `ruff check src/ tests/` - PASSED
- `pytest tests/ -v` - PASSED (24/24 tests)

**Test Results:**
- 6 registration tests: ALL PASSED
- 6 login tests: ALL PASSED
- 12 user model/repository tests: ALL PASSED
- Total: 24/24 tests passing

### Completion Notes List

**Implementation Summary:**

1. **JWT Configuration (Task 1):**
   - JWT configuration already existed from Story 1.2 (JWT_SECRET, JWT_EXPIRES_IN, JWT_ALGORITHM)
   - No additional changes needed

2. **JWT Token Creation (Task 2):**
   - Updated `src/core/security.py` with `create_access_token()` function
   - Implemented JWT encoding with python-jose library
   - Payload includes: sub (user_id), exp (expiry timestamp), iat (issued at timestamp)
   - Uses `timegm()` for proper UTC timestamp conversion
   - Defaults to settings.JWT_EXPIRES_IN (3600 seconds = 1 hour)

3. **Login Schemas (Task 3):**
   - LoginRequest and TokenResponse already created in Story 1.3
   - No additional changes needed

4. **Login Service Logic (Task 4):**
   - Updated `src/services/auth_service.py` with `login()` method
   - Finds user by email, returns 401 if not found
   - Verifies password with bcrypt, returns 401 if incorrect
   - Both failures return same "Invalid credentials" message (prevents email enumeration)
   - Generates JWT token and returns TokenResponse

5. **Login Route (Task 5):**
   - Updated `src/api/v1/auth.py` with POST /auth/login endpoint
   - Accepts LoginRequest, returns TokenResponse on success
   - Returns 200 OK with JWT token
   - Error handling delegated to service layer

6. **Test Suite (Task 6):**
   - Added 6 comprehensive login tests to test_auth.py:
     - Successful login with valid credentials
     - Invalid email rejection (401)
     - Incorrect password rejection (401)
     - JWT structure validation (sub, exp, iat fields)
     - JWT expiry verification (exp in future)
     - JWT signature validation (decodeable with secret)
   - Created test_user fixture for login tests
   - All tests use isolated test database

**Technical Achievements:**
- Secure authentication with bcrypt + JWT
- Proper error handling (same message for email/password failures)
- Token expiry configurable via environment variable
- Comprehensive test coverage for all scenarios
- OpenAPI documentation auto-generated by FastAPI

**Validations Passed:**
- ✅ Ruff linting
- ✅ All 24 pytest tests passing

### File List

**Modified:**
- `backend/src/core/security.py` - Added create_access_token() function for JWT generation
- `backend/src/services/auth_service.py` - Added login() method with password verification
- `backend/src/api/v1/auth.py` - Added POST /auth/login endpoint
- `backend/tests/test_auth.py` - Added 6 login tests and test_user fixture

**No New Files Created** (all files already existed from previous stories)

## QA Results
_To be populated by QA agent after implementation_
