# Story 2.1: Task Model & Repository

## Status
Ready

## Story

**As a** developer,  
**I want** Task data model and database repository,  
**so that** we can persist and query task data efficiently.

## Acceptance Criteria

1. Task Pydantic model defined with fields: id, title, description (optional), priority (enum: High/Medium/Low), deadline (ISO date string), status (enum: open/done), label_ids (array), owner_id (user reference), created_at, updated_at
2. Task repository class (`db/repositories/tasks_repo.py`) implements methods: create_task, find_by_owner, find_by_id, update_task, delete_task
3. MongoDB collection `tasks` properly indexes owner_id for efficient queries
4. Task model validation ensures: title required, priority is valid enum value, deadline is valid date format
5. Unit tests verify Task model validation and all repository methods using test database

## Tasks / Subtasks

- [ ] Task 1: Define Task Pydantic models (AC: 1, 4)
  - [ ] Create `backend/src/models/task.py`
  - [ ] Import Pydantic BaseModel, Field, field_validator
  - [ ] Create TaskPriority enum: `Literal['High', 'Medium', 'Low']`
  - [ ] Create TaskStatus enum: `Literal['open', 'done']`
  - [ ] Define `TaskBase` model with: title (str, min_length=1, max_length=200), description (Optional[str]), priority (TaskPriority), deadline (date)
  - [ ] Define `TaskCreate` schema extending TaskBase, optionally with label_ids (List[str] = [])
  - [ ] Define `TaskUpdate` schema with all fields optional
  - [ ] Define `TaskInDB` model with: id (str), status (TaskStatus = 'open'), label_ids (List[str] = []), owner_id (str), created_at (datetime), updated_at (datetime)
  - [ ] Define `TaskResponse` model (same as TaskInDB) for API responses
  - [ ] Add field validators for date format validation

- [ ] Task 2: Create Task schemas for API (AC: 1)
  - [ ] Create `backend/src/schemas/task.py`
  - [ ] Import task models from src.models.task
  - [ ] Re-export or create request/response schemas: TaskCreate, TaskUpdate, TaskResponse
  - [ ] Ensure schemas match OpenAPI specification

- [ ] Task 3: Implement Task repository (AC: 2, 3)
  - [ ] Create `backend/src/repositories/task_repository.py`
  - [ ] Implement `TaskRepository` class with `__init__(self, db: AsyncIOMotorDatabase)`
  - [ ] Implement `async def create_task(self, task_data: dict) -> TaskInDB`
  - [ ] Implement `async def find_by_owner(self, owner_id: ObjectId) -> List[TaskInDB]` - sort by created_at descending
  - [ ] Implement `async def find_by_id(self, task_id: ObjectId, owner_id: ObjectId) -> Optional[TaskInDB]` - verify ownership
  - [ ] Implement `async def update_task(self, task_id: ObjectId, owner_id: ObjectId, update_data: dict) -> Optional[TaskInDB]`
  - [ ] Implement `async def delete_task(self, task_id: ObjectId, owner_id: ObjectId) -> bool`
  - [ ] Create index on `owner_id` field in tasks collection
  - [ ] Create compound index on `owner_id + created_at` for sorted queries

- [ ] Task 4: Write unit tests for Task model (AC: 4, 5)
  - [ ] Create `backend/tests/test_task_model.py`
  - [ ] Test Task model with valid data: verify all fields accepted
  - [ ] Test title validation: empty title rejected, title > 200 chars rejected
  - [ ] Test priority validation: invalid priority value rejected
  - [ ] Test deadline validation: invalid date format rejected
  - [ ] Test optional fields: description can be None
  - [ ] Test default values: status defaults to 'open', label_ids defaults to []

- [ ] Task 5: Write unit tests for Task repository (AC: 5)
  - [ ] Create `backend/tests/test_task_repository.py`
  - [ ] Test create_task: inserts document, returns TaskInDB with id
  - [ ] Test find_by_owner: returns only tasks for specified owner_id
  - [ ] Test find_by_owner: returns empty list if no tasks
  - [ ] Test find_by_owner: tasks sorted by created_at descending
  - [ ] Test find_by_id: returns task if owner matches
  - [ ] Test find_by_id: returns None if owner doesn't match (ownership check)
  - [ ] Test update_task: updates specified fields, sets updated_at
  - [ ] Test delete_task: removes task, returns True
  - [ ] Test delete_task: returns False if task not found or owner mismatch

## Dev Notes

### Task Data Model

**[Source: docs/architecture/data-models.md#Task]**

The Task model represents a todo item with priority, deadline, and optional description.

**Key Attributes:**
- `id`: ObjectId â†’ string in API responses
- `title`: string (required, max 200 chars)
- `description`: string | null (optional)
- `priority`: enum('High', 'Medium', 'Low') - required
- `deadline`: date - ISO 8601 date string, required
- `status`: enum('open', 'done') - defaults to 'open'
- `label_ids`: array of ObjectId references (defaults to [])
- `owner_id`: ObjectId reference to User (required)
- `created_at`: datetime
- `updated_at`: datetime

**TypeScript Interface (for reference):**
```typescript
export type TaskPriority = 'High' | 'Medium' | 'Low';
export type TaskStatus = 'open' | 'done';

export interface Task {
  id: string;
  title: string;
  description: string | null;
  priority: TaskPriority;
  deadline: string; // ISO 8601 date
  status: TaskStatus;
  label_ids: string[];
  owner_id: string;
  created_at: string;
  updated_at: string;
}
```

### Pydantic Model Implementation

**[Source: docs/architecture/backend-architecture.md#Service Architecture]**

```python
from pydantic import BaseModel, Field, field_validator
from typing import Optional, List, Literal
from datetime import datetime, date
from bson import ObjectId

TaskPriority = Literal['High', 'Medium', 'Low']
TaskStatus = Literal['open', 'done']

class TaskBase(BaseModel):
    title: str = Field(min_length=1, max_length=200)
    description: Optional[str] = None
    priority: TaskPriority
    deadline: date  # Pydantic auto-validates date format

class TaskCreate(TaskBase):
    label_ids: List[str] = Field(default_factory=list)

class TaskUpdate(BaseModel):
    title: Optional[str] = Field(None, min_length=1, max_length=200)
    description: Optional[str] = None
    priority: Optional[TaskPriority] = None
    deadline: Optional[date] = None
    status: Optional[TaskStatus] = None
    label_ids: Optional[List[str]] = None

class TaskInDB(TaskBase):
    id: str
    status: TaskStatus = 'open'
    label_ids: List[str] = Field(default_factory=list)
    owner_id: str
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

TaskResponse = TaskInDB  # Alias for API responses
```

### Task Repository Pattern

**[Source: docs/architecture/backend-architecture.md#Database Architecture - Data Access Layer]**

Repository handles all MongoDB operations for tasks collection:

```python
from motor.motor_asyncio import AsyncIOMotorDatabase
from bson import ObjectId
from typing import List, Optional
from datetime import datetime

class TaskRepository:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.collection = db.tasks

    async def create_task(self, task_data: dict) -> TaskInDB:
        """Insert a new task document."""
        task_data['created_at'] = datetime.utcnow()
        task_data['updated_at'] = datetime.utcnow()
        task_data['status'] = task_data.get('status', 'open')
        task_data['label_ids'] = task_data.get('label_ids', [])
        
        result = await self.collection.insert_one(task_data)
        task_data['_id'] = result.inserted_id
        
        return TaskInDB(**self._doc_to_dict(task_data))

    async def find_by_owner(self, owner_id: ObjectId) -> List[TaskInDB]:
        """Find all tasks belonging to a user, sorted by created_at desc."""
        cursor = self.collection.find({'owner_id': owner_id}).sort('created_at', -1)
        tasks = await cursor.to_list(length=None)
        return [TaskInDB(**self._doc_to_dict(task)) for task in tasks]

    async def find_by_id(self, task_id: ObjectId, owner_id: ObjectId) -> Optional[TaskInDB]:
        """Find a task by ID, ensuring it belongs to the owner."""
        task = await self.collection.find_one({'_id': task_id, 'owner_id': owner_id})
        return TaskInDB(**self._doc_to_dict(task)) if task else None

    async def update_task(self, task_id: ObjectId, owner_id: ObjectId, update_data: dict) -> Optional[TaskInDB]:
        """Update a task's fields."""
        update_data['updated_at'] = datetime.utcnow()
        
        result = await self.collection.find_one_and_update(
            {'_id': task_id, 'owner_id': owner_id},
            {'$set': update_data},
            return_document=True
        )
        
        return TaskInDB(**self._doc_to_dict(result)) if result else None

    async def delete_task(self, task_id: ObjectId, owner_id: ObjectId) -> bool:
        """Delete a task."""
        result = await self.collection.delete_one({'_id': task_id, 'owner_id': owner_id})
        return result.deleted_count > 0
    
    def _doc_to_dict(self, doc: dict) -> dict:
        """Convert MongoDB document to dict with string id."""
        if doc and '_id' in doc:
            doc['id'] = str(doc['_id'])
            del doc['_id']
        if 'owner_id' in doc and isinstance(doc['owner_id'], ObjectId):
            doc['owner_id'] = str(doc['owner_id'])
        return doc
```

### Database Schema

**[Source: docs/architecture/database-schema.md#tasks Collection]**

**MongoDB Document Structure:**
```json
{
  "_id": ObjectId("..."),
  "title": "Complete project documentation",
  "description": "Write comprehensive docs",
  "priority": "High",
  "deadline": ISODate("2025-01-15"),
  "status": "open",
  "label_ids": [],
  "owner_id": ObjectId("..."),
  "created_at": ISODate("2025-01-12T10:30:00Z"),
  "updated_at": ISODate("2025-01-12T10:30:00Z")
}
```

**Required Indexes:**
- `owner_id`: Index for filtering tasks by user
- `owner_id + created_at`: Compound index for sorted queries (newest first)
- `_id`: Default primary key

**Index Creation:**
```python
# In startup event or migration
await db.tasks.create_index("owner_id")
await db.tasks.create_index([("owner_id", 1), ("created_at", -1)])
```

### Critical Security Rule

**[Source: docs/architecture/coding-standards.md#Database Operations]**

**CRITICAL:** All repository methods that fetch/update/delete tasks MUST verify ownership by including `owner_id` in the query filter. This prevents users from accessing other users' tasks.

**Correct Pattern:**
```python
# CORRECT: Includes owner_id in query
task = await self.collection.find_one({'_id': task_id, 'owner_id': owner_id})

# WRONG: Missing ownership check - security vulnerability!
task = await self.collection.find_one({'_id': task_id})
```

### File Locations

**[Source: docs/architecture/backend-architecture.md]**

Create these files:
- `backend/src/models/task.py` - Task Pydantic models
- `backend/src/schemas/task.py` - Task API schemas
- `backend/src/repositories/task_repository.py` - Task database operations
- `backend/tests/test_task_model.py` - Model validation tests
- `backend/tests/test_task_repository.py` - Repository tests

### Testing

**[Source: docs/architecture/testing-strategy.md#Backend Tests]**

**Test Coverage Requirements:**
- Unit tests for Pydantic model validation
- Unit tests for all repository methods
- Test ownership enforcement in find_by_id, update, delete
- Minimum 80% code coverage

**Test Fixture Example:**
```python
@pytest.fixture
async def test_task(test_db, test_user):
    """Create a test task for testing."""
    task_repo = TaskRepository(test_db)
    task_data = {
        "title": "Test Task",
        "priority": "High",
        "deadline": date(2025, 1, 20),
        "owner_id": ObjectId(test_user.id)
    }
    return await task_repo.create_task(task_data)
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-12 | 1.0 | Story created from Epic 2 | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent after implementation_
