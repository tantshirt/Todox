# Story 1.7: Frontend Authentication State & Protected Routes

## Status
Ready

## Story

**As a** user,  
**I want** my authentication state persisted and enforced,  
**so that** I remain logged in across page refreshes and cannot access protected pages without authentication.

## Acceptance Criteria

1. Authentication context/hook (`lib/auth.tsx`) manages: token storage, current user state, login/logout functions
2. Token is retrieved from storage on app initialization and validated
3. Protected routes (dashboard, tasks, labels) redirect to login if no valid token present
4. User can log out via logout button which clears token and redirects to login page
5. API client (`lib/api.ts`) automatically includes JWT token in Authorization header for all requests
6. Expired token triggers logout and redirect to login page
7. `/` root route redirects authenticated users to dashboard, non-authenticated to login

## Tasks / Subtasks

- [ ] Task 1: Create authentication context provider (AC: 1, 2)
  - [ ] Create `frontend/src/lib/auth.tsx`
  - [ ] Define `AuthContextType` interface with: user (User | null), isLoading (boolean), login(), register(), logout()
  - [ ] Create `AuthContext = createContext<AuthContextType>()`
  - [ ] Implement `AuthProvider` component
  - [ ] On mount: check localStorage for access_token, if exists fetch current user from GET /auth/me
  - [ ] If token invalid/expired: clear localStorage and set user to null
  - [ ] Implement login function: call API, store token, fetch user, redirect to /tasks
  - [ ] Implement register function: call API, show success, redirect to /auth/login
  - [ ] Implement logout function: clear token, set user to null, redirect to /auth/login

- [ ] Task 2: Create useAuth hook (AC: 1)
  - [ ] In `frontend/src/lib/auth.tsx`
  - [ ] Implement `export function useAuth()` that calls `useContext(AuthContext)`
  - [ ] Throw error if used outside AuthProvider
  - [ ] Return auth context value

- [ ] Task 3: Update root layout with AuthProvider (AC: 1, 2)
  - [ ] Update `frontend/src/app/layout.tsx`
  - [ ] Wrap children with `<AuthProvider>`
  - [ ] Also wrap with React Query `<QueryClientProvider>` if not already done
  - [ ] Add Toaster component from sonner for toast notifications

- [ ] Task 4: Create ProtectedRoute wrapper component (AC: 3)
  - [ ] Create `frontend/src/components/auth/ProtectedRoute.tsx`
  - [ ] Use `useAuth()` hook to get user and isLoading state
  - [ ] If isLoading: show loading spinner or skeleton
  - [ ] If not authenticated (!user): redirect to /auth/login using `useRouter`
  - [ ] If authenticated: render children
  - [ ] Use `useEffect` to handle redirect on auth state change

- [ ] Task 5: Protect task and label routes (AC: 3)
  - [ ] Update `frontend/src/app/tasks/page.tsx` (placeholder page for now)
  - [ ] Wrap page content with `<ProtectedRoute>` component
  - [ ] Update `frontend/src/app/labels/page.tsx` (placeholder page for now)
  - [ ] Wrap page content with `<ProtectedRoute>` component

- [ ] Task 6: Implement root route redirect logic (AC: 7)
  - [ ] Update `frontend/src/app/page.tsx`
  - [ ] Use `useAuth()` hook to check authentication state
  - [ ] If authenticated: redirect to /tasks using `useRouter`
  - [ ] If not authenticated: redirect to /auth/login
  - [ ] Handle loading state while checking auth

- [ ] Task 7: Update API client with automatic token injection (AC: 5, 6)
  - [ ] Update `frontend/src/lib/api.ts`
  - [ ] Create centralized request function that adds Authorization header from localStorage
  - [ ] If response is 401: clear token, redirect to /auth/login (expired token handling)
  - [ ] Refactor register() and login() to use centralized function

- [ ] Task 8: Add logout functionality to UI (AC: 4)
  - [ ] Create simple navigation component or update layout.tsx
  - [ ] Add "Logout" button visible on protected pages
  - [ ] Button calls `const { logout } = useAuth()` and `onClick={logout}`
  - [ ] Verify logout clears token and redirects to login

- [ ] Task 9: Update login and register pages to use auth context (AC: 1)
  - [ ] Update `frontend/src/app/auth/login/page.tsx` to use `login()` from useAuth hook
  - [ ] Update `frontend/src/app/auth/register/page.tsx` to use `register()` from useAuth hook
  - [ ] Remove duplicate API call logic

- [ ] Task 10: Manual testing of auth flow (AC: All)
  - [ ] Test: Register → Login → Access /tasks → Logout → Verify redirect to login
  - [ ] Test: Try accessing /tasks while logged out → Verify redirect to login
  - [ ] Test: Login → Refresh page → Verify still authenticated
  - [ ] Test: Remove token from localStorage → Refresh → Verify redirect to login

## Dev Notes

### Authentication State Management

**[Source: docs/architecture/frontend-architecture.md#State Management Architecture]**

Use React Context API for auth state (global client state) separate from React Query (server state).

**AuthContext Pattern:**

```typescript
'use client';

import { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { useRouter } from 'next/navigation';
import type { User, AuthResponse } from '@/types/auth';

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const router = useRouter();

  useEffect(() => {
    // Check for stored token on mount
    const token = localStorage.getItem('access_token');
    if (token) {
      fetchCurrentUser(token)
        .then(setUser)
        .catch(() => localStorage.removeItem('access_token'))
        .finally(() => setIsLoading(false));
    } else {
      setIsLoading(false);
    }
  }, []);

  const login = async (email: string, password: string) => {
    const response = await apiClient.post<AuthResponse>('/auth/login', { email, password });
    localStorage.setItem('access_token', response.access_token);
    const user = await fetchCurrentUser(response.access_token);
    setUser(user);
    router.push('/tasks');
  };

  const logout = () => {
    localStorage.removeItem('access_token');
    setUser(null);
    router.push('/auth/login');
  };

  return (
    <AuthContext.Provider value={{ user, isLoading, login, register, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
}
```

**[Source: docs/architecture/frontend-architecture.md#Protected Route Pattern]**

### Protected Route Implementation

```typescript
'use client';

import { useEffect, ReactNode } from 'react';
import { useRouter } from 'next/navigation';
import { useAuth } from '@/lib/auth';

export function ProtectedRoute({ children }: { children: ReactNode }) {
  const { user, isLoading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!isLoading && !user) {
      router.push('/auth/login');
    }
  }, [user, isLoading, router]);

  if (isLoading) {
    return <div>Loading...</div>; // Or skeleton loader
  }

  if (!user) {
    return null; // Will redirect via useEffect
  }

  return <>{children}</>;
}
```

### API Client with JWT Injection

**[Source: docs/architecture/frontend-architecture.md#API Client Setup]**

Centralized API client automatically adds JWT token to requests:

```typescript
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

class APIClient {
  private async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    const token = localStorage.getItem('access_token');
    
    const config: RequestInit = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...(token && { Authorization: `Bearer ${token}` }),
        ...options.headers,
      },
    };

    const response = await fetch(`${this.baseURL}${endpoint}`, config);

    if (!response.ok) {
      if (response.status === 401) {
        // Token expired or invalid
        localStorage.removeItem('access_token');
        window.location.href = '/auth/login';
        throw new Error('Session expired');
      }

      const error = await response.json().catch(() => ({ detail: 'Unknown error' }));
      throw new Error(error.detail || 'Request failed');
    }

    return response.json();
  }

  async get<T>(endpoint: string): Promise<T> {
    return this.request<T>(endpoint, { method: 'GET' });
  }

  async post<T>(endpoint: string, data: unknown): Promise<T> {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }
}

export const apiClient = new APIClient(API_BASE_URL);
```

### TypeScript Types

**[Source: docs/architecture/data-models.md#User]**

```typescript
export interface User {
  id: string;
  email: string;
  created_at: string;
  updated_at: string;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface RegisterRequest {
  email: string;
  password: string;
}

export interface AuthResponse {
  access_token: string;
  token_type: 'bearer';
  expires_in: number;
}
```

### File Locations

**[Source: docs/architecture/frontend-architecture.md#Component Organization]**

Create/update these files:
- `frontend/src/lib/auth.tsx` - Auth context and provider
- `frontend/src/components/auth/ProtectedRoute.tsx` - Protected route wrapper
- `frontend/src/lib/api.ts` - Update with JWT injection
- `frontend/src/app/layout.tsx` - Wrap with AuthProvider
- `frontend/src/app/page.tsx` - Root redirect logic
- `frontend/src/app/tasks/page.tsx` - Placeholder task page (protected)
- `frontend/src/app/labels/page.tsx` - Placeholder label page (protected)
- `frontend/src/types/auth.ts` - Auth-related TypeScript types

### Testing

**[Source: docs/architecture/testing-strategy.md]**

**Manual Testing Checklist:**
- ✓ Token persists after page refresh (localStorage inspection)
- ✓ Protected routes redirect when not authenticated
- ✓ Logout clears token and redirects
- ✓ Root route redirects based on auth state
- ✓ Expired token triggers logout (can test by manually expiring token in localStorage)

**E2E tests will be created in Story 1.8 with Playwright.**

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-12 | 1.0 | Story created from Epic 1 | Bob (SM) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent after implementation_
